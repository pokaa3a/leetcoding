#include <iostream>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <string>
#include <queue>
#include <stack>
#include <sstream>
#include <cmath>
#include <numeric>
using namespace std;

struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(NULL) {}
};

/* Solution */
const int MOD = 1000000007;
class Solution {
public:
    int minMalwareSpread(vector<vector<int> >& graph, vector<int>& initial) {
        vector<vector<int> > infected(graph.size(), vector<int>());
        set<int> init_nodes(initial.begin(), initial.end());

        for (int i = 0; i < initial.size(); ++i) {
        	bfs(initial[i], graph, init_nodes, infected);
        }

        vector<int> all_nodes(graph.size(), 0);
        for (int i = 0; i < infected.size(); ++i) {
        	cout << "node: " << i << " has " << infected[i].size() << " infected" << endl;
        	if (infected[i].size() == 1) {
        		cout << "initial node = " << infected[i][0] << endl;
        		all_nodes[infected[i][0]]++;
        	}
        }
        int ans = *min_element(initial.begin(), initial.end());

        if (accumulate(all_nodes.begin(), all_nodes.end(), 0) > 0) 
        	ans = max_element(all_nodes.begin(), all_nodes.end()) - all_nodes.begin();
        return ans;
    }
    void bfs(int node, vector<vector<int> >& graph, set<int>& init_nodes, vector<vector<int> >& infected) {
    	queue<int> q;
    	set<int> visited;

    	q.push(node);
    	visited.insert(node);

    	while (!q.empty()) {
    		int q_size = q.size();
    		for (int i = 0; i < q_size; ++i) {
    			int n = q.front();
    			q.pop();

    			if (n != node) infected[n].push_back(node);
    			for (int j = 0; j < graph.size(); ++j) {
    				if (graph[n][j] == 1 && init_nodes.count(j) == 0 && visited.count(j) == 0) {
    					q.push(j);
    					visited.insert(j);
    				}
    			}
    		}
    	}
    }
};

int main() {
	/* Solution */
	Solution sol;

	/* Test cases */

	/* [1-D vector] */
	// const int a = 1;
	// int arr[] = {};
	// vector<int> nums(arr, arr + a);

	/* [2-D vector] */
	const int rows = 7;
	const int cols = 7;
	int arr[rows][cols] = {{1,0,0,0,0,1,0}, 
						   {0,1,1,0,0,0,0}, 
						   {0,1,1,0,0,0,0}, 
						   {0,0,0,1,0,0,0},
						   {0,0,0,0,1,0,0},
						   {1,0,0,0,0,1,0},
						   {0,0,0,0,0,0,1}};
	vector<vector<int> > grid;
	for (int r = 0; r < rows; ++r) {
		grid.push_back(vector<int>(arr[r], arr[r] + cols));
	}
	int init[] = {4};
	vector<int> initial(init, init + 1);

	cout << sol.minMalwareSpread(grid, initial) << endl;

	/* [String] */
	// string str = "";

}